# [ARC165](https://atcoder.jp/contests/arc165/tasks)

## [A-Sum equals LCM]()

题意给定一个N，找到一个多于两个元素的序列，使得：
$$
\sum_{i=1}^{n}{a_{i}}=N \\
lcm_{i=1}^{n}\{a_{i}\}=N
$$

### 思路
看到**lcm**，首先需要想到素数相关的知识，从分解N的角度去看待这个事情，想到：
$$
N=p_{1}^{k1}p_{2}^{k2}p_{3}^{k3}p_{4}^{k4} ······ p_{k}^{k}  
$$
因此，如果一个数字分解出来的和是小于N的，那么可以通过补1的方式卡掉；反之，如果是大于，那就无。于是需要进行充分判断，即分解出来最小的情况大于N的时候，输出NO。
同一个N分解出来满足lcm最小的情况的情况一定是： $sum = p_{1}^{k1}+p_{2}^{k2}+p_{3}^{k3}+p_{4}^{k4}+ ······ +p_{k}^{k}$，均值不等式告诉的大概方向。
再从样例中N=4和N=6的样例示例里面看。发现4不行是因为只有一种素数，最少都是它自己出现；而6可以是因为包含两种素数。同时发现：1是不影响lcm而影响gcd的。
所以判断的关键又出现了以一个--分解出来的个数有多少个？
如果不确定的话，直接开始枚举6、21、24，和4、8、16这些数字去分解，发现就是不能只有一个素数。
因此这个数如果是质数或者是指数的k次方肯定是不行的。
但是这样硬分，是不可能的，因为N是1e9的数据，但是当时没想出来如何。后面发现，其实先判断他是不是质数，后面再取数是不是只有一个素数。数的时候又有一个问题，不能全部数完，而是你数到第一素数因子之后，把素数因子全部除掉，看看他是不是1，这样很快就过了。

```CPP
#include<bits/stdc++.h>
using namespace std;

#define ll long long 
int main(void)
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n;
		scanf("%d",&n);
		// 是不是素数
		auto check1=[](int num)-> bool {
			for(int i=2;1ll*i*i<=num;++i)
			{
				if(num%i==0)
					return false;
			}
			return true;
		};

		// 是不是只包含一个素数因子
		auto check2=[](int num)-> bool {
			for(int i=2; i<=num ;++i)
			{
				if(num%i==0){
					while(num%i==0)
						num/=i;
					break;
				}
			}
			return num>1;
		};


		if(n>4 && !check1(n) && check2(n) )puts("Yes");
		else puts("No");
	}
	return 0;
}
```

但是可以注意到，两个check函数的工作有一点重复；同样的代码，只是小改了一下，属实不太行。这个就是最初步的质因数分解算法。

```CPP
bool divede(int num)
{
	bool flag=0;
	for(int i=2;1ll*i*i<=num;++i)
	{
		if(num%i==0){
			while(num%i==0)
				num/=i;
			flag=true;		
			break;
		}
	}
	return flag && num>1;
}
```
### Miller-Rabin和Pollard-Rho算法




## [B-Sliding Window Sort 2]()

### 思路

## [C-Social Distance on Graph]()
### 思路
## [D-Substring Comparison]()
### 思路
## [E-Random Isolation]()
### 思路
## [F-Make Adjacent]()
### 思路



