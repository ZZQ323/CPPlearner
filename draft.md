<style>
  p {
    line-height: 1.5;
  }
    span[style^="font-size:1.2em"] {
      line-height: 1.5;
    }
</style>


# A - Training Before the Olympiad

考点：贪心策略、策略不变时候的周期性 

分析博弈策略。只有当奇数加偶数的时候才能让数值下降，需要抬高数值的一方应该尽可能消耗奇数防止对方使用，而降低一方也是同理，优先使用奇数加上偶数。  
会不会出现没有偶数的尴尬呢？必定不会。在最优策略下，只要进行了一次计算过后，就会产生一个偶数，只要开始进行计算，偶数源源不断增加。  
先手的人需要让数值最大，而后手的人需要消耗奇数。很容易陷入到“轮数”和“奇数个数”之间的讨论之中。事实上，二者的发挥和轮数是没有半毛钱关系的。只要有奇数而且够凑出一对，先手就会凑对；而后手会因为有奇数就使用。二者会用到奇数完全被消耗完成为止。除非，轮次只有一次（特判情况）。   
奇数很多的话，那么先手+后手的策略会构成周期为3的循环。循环剩下来的，可能为1、2。如果是1的话，先手不够凑对，但是也只能硬着头皮加，因为后手一定也会这么做；但是如果是2，那就凑对，再好不过了。

# B - Three Activities

考点：次大值、次次大值 

三个序列，各找一个a、b、c使得a+b+c最大，且三者下标不同。  
如果这里采用原始的查找方式，O($n^3$)，这是不能接受的。只能分开来找最大值，最大值存在重合的情况，那么这个时候可以用次大值去替换一个最大值。
注意，就一个，同时替换三个的依旧可能会重合；但是既然最大的重合了，第二的就绝对不可能和之前那个最大的重合了。 
同样的万一次大数值也重合了，那么找次次大值。 
和找树的直径是一样的，如果只是盯着全局最大值去找，那肯定超时，但是只找一边，只凭借一个最大值来判断乘积、加和的最大值，也大概率是错的。  
而这种最大值会因为某种原因被舍弃，而次大值就可以顺利接替的情况，要考虑到。 

# C - Make Almost Equal With Mod 

考点：特殊到一般思维的猜想 

先说数学结论:  
$$ x \quad mod  \quad k == 0 \\x \quad  mod  \quad 2k == k \quad  or \quad  0 $$

在做题过程中，突然被样例提醒到，用k=2就可以分开所有的奇数和偶数，产生且仅产生两种不同的mod值，这里需要运用到“特殊解和通解”的联系。  
和解微分方程一样，特殊解是通解的必要一环；解出特殊解往往意味着解出通解。比如：一阶常系数齐次线性微分方程 和 一阶常系数非齐次线性微分方程 的关系一样。

$$
\frac{dy}{dx}+ay=0 \\ \\
\frac{dy}{dx}+ay=f(t) 
其中\frac{dy}{dx}+ay=0的解y_p(t)=Ce^{−at} \\ \\
满足\frac{dy_p(t)}{dx}+ay_p(t)=f(t) 
$$

因此很多时候，特解和通解的关系是解题的关键。  
这里借着2自由发挥。如果全是奇数和全是偶数的时候，我们并不能很好地区分他们，因为他们mod 2全是0或者全是1。
这个时候反过来想，如果有一个k让他们恰好可以得到两个数值，会是什么呢？   
答案很关键，就是0和k/2  

# D - StORage room

考点：按位运算性质 

这里考的是|的相互溶解的性质。如果一个数字是由两个数字|来的；那么，这个数字包含有两个数字的一部分。如果这个数字和一群数字b按位或出来了一群c，那么这群c都包含有a的性质。  
如果连续在c之间相互&，那么最终的结果就不断地趋向a。也就是，我们可以通过所有的共性去找原来的个性。   

# E - Fear of the Dark 

考点：简单的计算几何分类讨论 

分类：离一个点近，离两个点分别近，离两个点都有点远灯先接触

# F - Perfect Square 

考点：简单矩阵旋转模拟 

主要是矩阵的旋转怎么写：

$$ 
M[i][j] \stackrel{\text{顺时针90\degree}}{\rightarrow} 
M[j][n-i+1] \stackrel{\text{顺时针90\degree}}{\rightarrow}  
M[n-i+1][n-j+1] \stackrel{\text{顺时针90\degree}}{\rightarrow} 
M[n-j+1][i] 
$$

她所要求的旋转不变性，其实就是这四个相等。同时又只能加不能减，那么取最大值，然后求和记录操作次数。

# G - Joyboard 

考点：观察、分类 

其实k就三个值，没有0也没有大于3的，简单枚举就可以看出来。

然后对于m和n之间的关系需要进行讨论，否则会出现重复和遗漏。比如在m大于n时候，整除情况下k还是2，但是如果只想到了m小于n的时候，根本不会意识到这一点。

枚举观察，细细分类

# H - Jellyfish and Game

考点：贪心策略、策略不变时候的周期性

最终的目的是使得自己最大化。
首先，不可能傻到把自己大的给别人，肯定是用最小的换别人最大的，最赚。但是别人也是这么想的，同样的策略：“最小换最大”，是两个人共同目标。

注意每一次操作完后，每个人要抢的最大值可能是不一样。强的可能是共同的最大值或者次大值，当然，最终还是会落脚到最大值的争抢上面，谁认不准那个最大值呢？

无论如何先一次交换，第一次可能不交换，最小值比对方大。但是对方开始抢过来的时候，就会不断地用自己的最小值互相争抢最大值。如果说第一次不交换，那么抢的人换来的最小值一定是全局最小的；如果交换了，那么一定会被对方用做筹码交换会最大值。

交换不断地发生在全局最小和全局最大的交换上面 --- 除了第一次，第一次的人可以不叫唤，但是之后受策略”驱使，就一定会交换。

# I - Plus Minus Permutation 

考点：贪心策略

说白了，就是抽取x的倍数的下标为一组，y倍数的下标为一组，然后相减得到最大。  
首先考虑最大化差值，肯定是最大的给x，最小的给y。

然后就做完了……

# J - Friendly Arrays 

考点：按位运算性质 
先做a|=b，然后进行异或。这里异或得到的x和b有这样的关系：如果是奇数，那么x应该是获得了b，反之失去了b。  
获得就是sum|b，失去就是sum&(~b)   
一个个地做，然后取最大、最小值。注意不同的b是可以相互组合的，也就是说，如果这个b让你变大变小了，你就应该保存它。

`tmp=max(tmp,tmp|b)` 而不是 `tmp=max(tmp,sum|b)`

# K - Fancy Coins 

考点：贪心策略 

明确策略：用k肯定比用1要少。如果要用最少的fancy，那么应该多用k，所以把余数留给1。
如果k不足，那么1可以去换k；如果1不足，那么k就不能换。 
还有一点：要么缺1，要么不缺；不缺的时候考虑换k


