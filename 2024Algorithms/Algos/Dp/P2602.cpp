#include<iostream>
#include<algorithm>

#define ll long long 
#define llu long long unsigned

const int N=17;
llu dp[N],ten[N];

/**
 * ten[]是10的次幂，ten[i]就是10^i
 * dp[i]是第i个位子上固定为数字i的时候，且数字只有i位的时候，有多少个数字满足
 * 
*/


void init()
{
    ten[0]=1;
    for(int i=1;i<=N;++i)
    {
        dp[i]=i*ten[i-1];
        ten[i]=ten[i-1]*10;
    }
}

template<class T>
void solve(T number,T cnt[N])
{
    int len=0;
    int num[N];
    while(number)
    {
        num[++len]=number%10;
        number/=10;
    }

    for(int i=len;i>=1;--i)
    {

        /**
         * num[i]作为第一位的时候
         * 一位数，选一个j有1种
         * 两位数，选考虑j个数的时候，只看一位的话就是10个
         * 三位数，考虑一个位子上的j就是100
         * 思路是固定位数，来数清楚这个位子上有多少个j
         * 
         * 这里cnt[j]+=dp[i-1]*num[i]考虑的是：
         *      长度为i的数字的后面i-1个数字，出现了多少个数字j
         * 
         * 而这个cnt[j]+=ten[i-1]，数的是第i位上，满足出现数字j的个数
         * 
        */
        // 0 ~ num[i]-1 
        for(int j=0;j<=9;++j){
            cnt[j]+=dp[i-1]*num[i];
        }
        /**
         * 减去上一步考虑的 10XXX、20XXX等等
         * 是dp的问题
         * 所以是减掉前面所有dp关于0的枚举
         */
        cnt[0]-=ten[i-1]; 
        
        for(int j=0;j<num[i];++j)
            cnt[j]+=ten[i-1];  
        /**
         * 当ABCD这个数字，
         *  数完了 0XXX、1XXX、(A-1)XXX 里面包含的数字j的个数
         *  数完了 jXXX 第一位是j的数字的个数，也就是j在第一位上出现了多少次
         *  剩下就只需要数A000-ABXX、AB00-ABC0、ABC0-ABCD里面单独给A贡献了多少个数字了
         * 
         * 为什么不数在 A000-ABCD 给大于A的数字贡献了多少呢，漏了吗？
         *  数位DP通过划分数字的位置来对数字进行榨干
         *  一个数字能贡献的地方有：开头、后面部分
         * 在分块枚举的过程中，必须注意不是所有数字都能拿来榨汁的，因为超过范围了。
         *  dp[i]就是把长度为i的里面的所有数字能够提供的xx（1、2、3……）数，全部抽出来
         *  而ten[i]就是榨汁榨干头部，计算头部贡献，
         *  这样一个（群）数字就被榨干了。
         * 
         *  剩下的，没有被计算的，只能是不断地通过固定前面的位数，筛选出可以枚举的范围，然后来计算
         *  每次枚举的都是一个范围，每次都是群体伤害，
         *  但是不要以为枚举的数字是一样的，因为每次在固定越来越多的位数，
         *  分析后面的时候前面已经固定了，而前面的枚举有没有涉及到固定的部分
         * 
         * 而在范围内的榨汁，只能通过循序渐进地逼近一个数字的上界来完成。 
        */


        // 考虑每一位number上的数字的出现的次数
        T num2=0;
        for(int j=i-1;j;--j)
            num2 = num2*10+num[j];   
        cnt[num[i]]+= num2+1;
        
        /** 未解之谜
         * 下一位不能还是0。
         * 如果允许这样，那么0的下一个可以还是0，下一个也可以还是0
         * 考虑 00010 00020 ，这不就是前导0吗？
         * 没有前导0这样的数字，这样是不合法的，但是因为数位dp把数字当成字符串枚举
         * 所以这里需要减去。
         * 
         * 之前有疑惑，就是想问0有时候都没有重复相加，甚至都没有加（digits[now]=0的时候）为什么要减去呢？
         * 答案在于cnt[j]+=dp[i-1]*num[i] 这里每一位数都加了，
         * 枚举的过程中，由于是用组合数学的思维来枚举，没有限制0的出现
         * 所以在dp里面，一定会有0跟在第一个0的屁股后面的。
         * 
         * 加了又减去，为什么还要更新0的cnt数值呢？
         * 注意，问题在于“有0跟”，而不是全部都是0跟着，01099和00199是同时出现在dp里面的
         * 况且，当首字母不是0的时候，这样的全随机的数才是每一位数出现次数的真正答案
         * 所以只需要减去 0打头的 这种情况就可以了，总共是0XXXX ，也就是ten[i-1]
        */
    }
}

llu cnt1[N],cnt2[N];

signed main(void)
{
    llu a,b;
    scanf("%lld %lld",&a,&b);
    init();
    // solve(a,cnt1);
    solve(a-1,cnt1);
    solve(b,cnt2);
    for(int i=0;i<=9;++i)
        printf("%lld ",cnt2[i]-cnt1[i]);
    puts("");
    return 0;
}